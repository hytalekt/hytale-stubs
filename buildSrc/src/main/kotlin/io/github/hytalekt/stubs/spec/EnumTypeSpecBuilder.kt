package io.github.hytalekt.stubs.spec

import com.palantir.javapoet.TypeSpec
import io.github.classgraph.ClassInfo
import io.github.hytalekt.stubs.util.buildField
import io.github.hytalekt.stubs.util.buildMethod
import io.github.hytalekt.stubs.util.classModifiersOf
import io.github.hytalekt.stubs.util.isSyntheticAccessor

class EnumTypeSpecBuilder(
    private val classInfo: ClassInfo,
) : TypeSpecBuilder {
    override fun build(): TypeSpec {
        require(classInfo.isEnum) {
            "Attempted to build an enum TypeSpec using a non-enum class"
        }

        val typeSpec = TypeSpec.enumBuilder(classInfo.simpleName)

        addModifiers(typeSpec)
        addAnnotations(typeSpec)
        addEnumConstants(typeSpec, classInfo)
        addFields(typeSpec)
        addMethods(typeSpec)
        addInnerClasses(typeSpec)

        return typeSpec.build()
    }

    private fun addModifiers(typeSpec: TypeSpec.Builder) {
        // Enums are implicitly final, so we filter out the FINAL modifier
        val modifiers =
            classModifiersOf(classInfo.modifiers)
                .filter { it != javax.lang.model.element.Modifier.FINAL }
        typeSpec.addModifiers(*modifiers.toTypedArray())
    }

    private fun addAnnotations(typeSpec: TypeSpec.Builder) {
        classInfo.annotationInfo?.forEach { annotationInfo ->
            typeSpec.addAnnotation(buildAnnotationSpec(annotationInfo))
        }
    }

    private fun addFields(typeSpec: TypeSpec.Builder) {
        // Add non-enum-constant fields (e.g., private final String description)
        classInfo.fieldInfo
            .filter { !it.isEnum && !it.isSynthetic }
            .forEach { fieldInfo ->
                typeSpec.addField(buildField(fieldInfo))
            }
    }

    private fun addMethods(typeSpec: TypeSpec.Builder) {
        // Don't add constructors for enums - they can't be instantiated at runtime

        // Add regular methods, excluding compiler-generated methods
        classInfo.methodInfo
            .filter { !it.isSynthetic || !isSyntheticAccessor(it) }
            .filter { !it.isBridge } // Filter out bridge methods (type erasure)
            .filter { !it.name.startsWith("$") }
            // Exclude values() and valueOf(String) as they're auto-generated by Java compiler
            .filter { !(it.name == "values" && it.parameterInfo.isEmpty()) }
            .filter { !(it.name == "valueOf" && it.parameterInfo.size == 1) }
            .forEach { methodInfo ->
                typeSpec.addMethod(buildMethod(methodInfo, classInfo))
            }
    }

    private fun addInnerClasses(typeSpec: TypeSpec.Builder) {
        classInfo.innerClasses
            .filter { !it.isAnonymousInnerClass && !it.isSynthetic }
            // Only include direct children - filter out nested inner classes
            .filter { innerClassInfo ->
                val outerClass = innerClassInfo.outerClasses?.firstOrNull()
                outerClass?.name == classInfo.name
            }.forEach { innerClassInfo ->
                val innerTypeSpec = buildInnerClassTypeSpec(innerClassInfo)
                typeSpec.addType(innerTypeSpec)
            }
    }
}

private fun addEnumConstants(
    typeSpec: TypeSpec.Builder,
    clazz: ClassInfo,
) {
    clazz.fieldInfo
        .filter { it.isEnum }
        .forEach { typeSpec.addEnumConstant(it.name) }
}
